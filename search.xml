<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法java初识</title>
      <link href="2021/05/06/suan-fa-java-chu-shi/"/>
      <url>2021/05/06/suan-fa-java-chu-shi/</url>
      
        <content type="html"><![CDATA[<p>递归：自己调自己，效率非常不好。使用递归测算可能会卡主程序，因为慢；</p><p>循环：速度很快，因为是异步进行的？</p><p>所谓算法，其实就是，比对各种不同测算结果的优劣，取最优！（以后再补充）</p><p>java 的函数需要在主函数main里调，out规定输出什么值；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法、java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antdPopover的动态变色和动态visable</title>
      <link href="2021/05/05/antdpopover-de-dong-tai-bian-se-he-dong-tai-visable/"/>
      <url>2021/05/05/antdpopover-de-dong-tai-bian-se-he-dong-tai-visable/</url>
      
        <content type="html"><![CDATA[<h5 id="目的：-使用Popover制作动态的变色和控制Visable"><a href="#目的：-使用Popover制作动态的变色和控制Visable" class="headerlink" title="目的： 使用Popover制作动态的变色和控制Visable"></a>目的： 使用Popover制作动态的变色和控制Visable</h5><p>引入相关文件</p><pre><code class="js">import React, &#123; useState &#125; from &#39;react&#39;;import cxs from &#39;classnames&#39;import &#123; Popover &#125; from &#39;antd&#39;;import &#39;../../iconfont/iconfont.css&#39;import &quot;./popovers.css&quot;;</code></pre><pre><code class="jsx">function Popovers() &#123;  const [chooseIndex, setChooseIndex] = useState(undefined)  const list = [    &#123; &quot;name&quot;: &quot;Rose&quot;, &quot;age&quot;: 22 &#125;,    &#123; &quot;name&quot;: &quot;Eric&quot;, &quot;age&quot;: 18 &#125;,    &#123; &quot;name&quot;: &quot;Mary&quot;, &quot;age&quot;: 25 &#125;,    &#123; &quot;name&quot;: &quot;Lucy&quot;, &quot;age&quot;: 28 &#125;,    &#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 21 &#125;,    &#123; &quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 29 &#125;,    &#123; &quot;name&quot;: &quot;Bruce&quot;, &quot;age&quot;: 27 &#125;,    &#123; &quot;name&quot;: &quot;Tian&quot;, &quot;age&quot;: 25 &#125;,    &#123; &quot;name&quot;: &quot;JuDiao&quot;, &quot;age&quot;: 24 &#125;,    &#123; &quot;name&quot;: &quot;Niuheng&quot;, &quot;age&quot;: 31 &#125;,    &#123; &quot;name&quot;: &quot;KaiDi&quot;, &quot;age&quot;: 26 &#125;,    &#123; &quot;name&quot;: &quot;Haohao&quot;, &quot;age&quot;: 26 &#125;,    &#123; &quot;name&quot;: &quot;Wind&quot;, &quot;age&quot;: 23 &#125;  ]  const closeList = (index) =&gt; &#123;    console.log(&#39;close&#39;)    setChooseIndex()  // 每次关闭也会重新return？ 渲染的是全部视图还是局部视图    // stopPropagation 阻止事件冒泡  &#125;  const renderContent = (item, index) =&gt; &#123;  // 函数组件的函数，还必须const    console.log(item)    return &lt;div className=&#123;cxs(&#39;content-wrap&#39;)&#125;&gt;      &lt;div className=&#123;cxs(&quot;content-top&quot;)&#125;&gt;        &lt;div className=&#123;cxs(&#39;content-top-left&#39;)&#125;&gt;&lt;h1&gt;Name:&lt;/h1&gt;&lt;p&gt;&#123;item.name&#125;&lt;/p&gt;&lt;/div&gt;        &lt;div         onClick=&#123;(e) =&gt; &#123;          e.stopPropagation()   // 此处必须阻止冒泡事件，否则会触发父元素的点击事件，导致子元素的点击事件点击了但是没效果          closeList(index)      // ***这是因为事件冒泡触发父元素点击对值重新赋值了***        &#125;&#125;        className=&#123;cxs(&#39;content-top-right&#39;)&#125;&gt;          &lt;i className=&quot;icon iconfont&quot;&gt;&amp;#xe607;&lt;/i&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div className=&#123;cxs(&quot;content-bottom&quot;)&#125;&gt;        &lt;h2&gt;Have a good nice Day !&lt;/h2&gt;      &lt;/div&gt;    &lt;/div&gt;  &#125;  const changeColorAndIndex = (item, index) =&gt; &#123;    // console.log(item, index)    // console.log(&#39;changeIndex&#39;)    setChooseIndex(index)   // 中间值与下标相等了 ，完成了两件事，被点击元素变色，被点击元素的pop显示，其他不显示！  &#125;   return (    &lt;div className=&#123;cxs(&#39;wrap&#39;)&#125;&gt;      &lt;header&gt;点名&lt;/header&gt;      &#123;list.map( (item, index) =&gt; &#123;        return &lt;div         key=&#123;index&#125;        id=&#39;item-info&#39;            className=&#123;cxs(&#123;&quot;activeIndex&quot;: chooseIndex === index&#125;)&#125;  //1. 若类名与中间值相等，就出现变化的背景色        onClick=&#123;() =&gt; &#123;changeColorAndIndex(item, index)&#125;&#125;    //3.  使中间值和下标相等的事件。触发器        &gt;        &lt;Popover          content=&#123;renderContent(item, index)&#125;          trigger=&quot;click&quot;          getPopupContainer=&#123;() =&gt; document.getElementById(&quot;item-info&quot;)&#125;  // 绑定渲染父级          visible=&#123;chooseIndex === index&#125;     //2. 同理，若下标和中间值相同就显示        &gt;          &lt;div className=&#123;cxs(&quot;item-onfo1&quot;)&#125;&gt;            &lt;div className=&#123;cxs(&#39;item-info-left&#39;)&#125;&gt;&#123;item.name&#125;&lt;/div&gt;            &lt;div className=&#123;cxs(&#39;item-info-right&#39;)&#125;&gt;&#123;item.age&#125;&lt;/div&gt;          &lt;/div&gt;        &lt;/Popover&gt;      &lt;/div&gt;      &#125;)&#125;    &lt;/div&gt;  )&#125;export default Popovers</code></pre><h5 id="关于为什么popover要绑定父级"><a href="#关于为什么popover要绑定父级" class="headerlink" title="关于为什么popover要绑定父级"></a>关于为什么popover要绑定父级</h5><pre><code class="jsx">// popover的默认渲染父级是body ，这在有些时候会出问题，例如元素错位(当然在目前看来是没有问题的，为了严谨)getPopupContainer=&#123;() =&gt; document.getElementById(&quot;item-info&quot;)&#125;</code></pre><h5 id="css"><a href="#css" class="headerlink" title="css:"></a>css:</h5><pre><code class="css">// 给父级元素相对定位，高度// 给子元素向左的距离.ant-popover &#123;    left: 415px  !important;    top: 0 !important;&#125;.ant-popover-arrow&#123;    display: none  !important;&#125;.ant-popover-inner-content&#123;    padding: 0  !important;    width: 400px;    height: 270px;&#125;</code></pre><h6 id="完整css"><a href="#完整css" class="headerlink" title="完整css"></a>完整css</h6><pre><code class="css">.wrap&#123;    width: 400px;    height: 900px;    margin-top: 40px;    margin-left: 50px;    background: rgba(0, 0, 0, .6);&#125;header&#123;    height: 50px;    margin-bottom: 15px;    /* text-align: center; */    line-height: 50px;    font-size: 18px;    color: seagreen;    padding-left: 16px;    font-weight: 700;&#125;#item-info&#123;    height: 40px;    padding: 0 16px;    position: relative;&#125;.activeIndex&#123;    background: #cccccc;&#125;.item-onfo1&#123;    height: 100%;    display: flex;    font-size: 14px;    padding: 11px 0;    justify-content: space-between;    border-bottom: 1px solid #cccccc;&#125;.item-info-left&#123;    color: blueviolet;&#125;.item-info-right&#123;    color: brown;&#125;.ant-popover &#123;    left: 415px  !important;    top: 0 !important;&#125;.ant-popover-arrow&#123;    display: none  !important;&#125;.ant-popover-inner-content&#123;    padding: 0  !important;    width: 400px;    height: 270px;&#125;/* content */.content-wrap&#123;    padding: 14px 16px;    height: 100%;&#125;.content-top&#123;    height: 50px;    display: flex;    justify-content: space-between;&#125;.content-bottom&#123;    /* less 预编译  要  calc(~&quot;100% - 50px&quot;) */    height: calc(100% - 50px);  &#125;.content-top-left&#123;    display: flex;&#125;.content-top-left p&#123;    margin-left: 20px;    line-height: 50px;&#125;.content-top-left h1&#123;    color: crimson;&#125;.content-top-right &#123;    line-height: 50px;&#125;.content-top-right i &#123;    color: lightseagreen;    font-weight: 800;&#125;.content-bottom h2&#123;    color: dodgerblue;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> aned Popover </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoComplute制作模糊搜索</title>
      <link href="2021/05/05/autocomplute-zhi-zuo-mo-hu-sou-suo/"/>
      <url>2021/05/05/autocomplute-zhi-zuo-mo-hu-sou-suo/</url>
      
        <content type="html"><![CDATA[<h5 id="1-引入React-useState-classnames插件，引出Option"><a href="#1-引入React-useState-classnames插件，引出Option" class="headerlink" title="1. 引入React, useState classnames插件，引出Option"></a>1. 引入React, useState classnames插件，引出Option</h5><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;;import cxs from &#39;classnames&#39;import &#123; AutoComplete &#125; from &#39;antd&#39;;import &#39;./dimserch.css&#39;const &#123; Option &#125; = AutoComplete</code></pre><p><strong>思路</strong> ：</p><p>将一份数据存两遍，一份用于渲染，一份用于查找。</p><p>由于传入的  搜索值(serch)或是 变化值(onChange)的值若是空字符串，那么只需在另一份保存的数据中查找就可以了；</p><pre><code class="js">filter，用list.filter( item =&gt; &#123;   // 第一种写法  1    if(item.includes.val) return true   // 若item包含传入值，返回此对象      //第二种写法   2  // const regex = new RegExp(val)  // if(regex.test(item)) return true  return false 其他情况不返回！&#125;)</code></pre><h5 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h5><pre><code class="jsx">function DimSerch() &#123;  const list =    [      &quot;双皮奶&quot;, &quot;狮子头&quot;, &quot;擀面皮&quot;, &quot;巧克力蛋糕&quot;, &quot;热米皮&quot;, &quot;牛肉面&quot;, &quot;二细牛肉面&quot;, &quot;三细牛肉面&quot;,      &quot;扬州炒饭&quot;, &quot;蛋炒饭&quot;, &quot;蛋炒土豆丝&quot;, &quot;巧克力饼&quot;, &quot;狮子头拌奶酪&quot;, &quot;火腿擀面皮&quot;, &quot;加量擀面皮&quot;,      &quot;热米皮拌青椒&quot;, &quot;双皮奶加量&quot;, &quot;海之言&quot;, &quot;蓝色海之言&quot;, &quot;紫色海之言&quot;, &quot;橘黄海之言&quot;, &quot;绿色海之言&quot;,      &quot;百吉猫锅巴&quot;, &quot;三元锅巴&quot;, &quot;酥锅巴&quot;, &quot;AD钙&quot;, &quot;乳酸菌AD钙&quot;, &quot;草莓AD钙&quot;, &quot;香辣火腿肠&quot;, &quot;玉米火腿肠&quot;    ]  const [realyDatas, setRealyDatas] = useState(list)  const [originList, setoriginList] = useState(list)  const handleSearch = (val) =&gt; &#123;    // const regex = new RegExp(val)  //定义规则(传入值);若val是空字符串，那么所有被检验元素都包含&#39;&#39;，      // 也就是说，此时返回被遍历对象的所有（每一项）;    let newArray = originList.filter((item) =&gt; &#123;      // if (regex.test(item)) &#123;      // 若每一项包含所定义规则；所有字符都包含空字符串；      //   return true                // 就返回这个对象      // &#125;      if(item.includes(val)) return true // item包含输入的值，返回此对象；其他情况false不返回      return false    &#125;)    setRealyDatas(newArray)          // 更新渲染数组； 重新渲染  &#125;    const autoChange = (val) =&gt; &#123;    // const regex = new RegExp(val)    let newArray = originList.filter((item) =&gt; &#123;      // if (regex.test(item)) &#123;      //   return true      // &#125;      if(item.includes(val)) return true      return false    &#125;)    setRealyDatas(newArray)  &#125;  return (    &lt;div id=&#39;wrap&#39;&gt;      &lt;AutoComplete        getPopupContainer=&#123;() =&gt; document.getElementById(&quot;wrap&quot;)&#125;        onSearch=&#123;handleSearch&#125;        onChange=&#123;autoChange&#125;        placeholder=&quot;请输入&quot;      &gt;        &#123;realyDatas.map((item, index) =&gt; (          &lt;Option value=&#123;item&#125; key=&#123;item&#125;&gt;            &#123;item&#125;          &lt;/Option&gt;        ))&#125;      &lt;/AutoComplete&gt;    &lt;/div&gt;  )&#125;export default DimSerch</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 模糊搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="2021/04/30/sui-bi/"/>
      <url>2021/04/30/sui-bi/</url>
      
        <content type="html"><![CDATA[<h4 id="4-10-4-16-report"><a href="#4-10-4-16-report" class="headerlink" title="4.10-4.16 report"></a>4.10-4.16 report</h4><h5 id="1-Object-keys-obj-传入对象，返回属性名"><a href="#1-Object-keys-obj-传入对象，返回属性名" class="headerlink" title="1) Object.keys(obj)  // 传入对象，返回属性名"></a>1) Object.keys(obj)  // 传入对象，返回属性名</h5><pre><code class="js">let obj = &#123;type: &quot;上午&quot;,list:&quot;333&quot;, dance:&quot;巴克勒&quot;&#125; console.log(Object.keys(obj)) // (3) [&quot;type&quot;, &quot;list&quot;, &quot;dance&quot;]  返回键名，但并没有吃掉属性值</code></pre><h5 id="2-classList添加类名"><a href="#2-classList添加类名" class="headerlink" title="2) classList添加类名"></a>2) classList添加类名</h5><pre><code class="js">var bot = document.getElementById(&#39;bot&#39;)bot.classList.add(&#39;niuheng&#39;)     // console.log(bot.classList.contains(&#39;niuheng&#39;)) // true</code></pre><h5 id="3）-map的参数"><a href="#3）-map的参数" class="headerlink" title="3） map的参数"></a>3） map的参数</h5><pre><code class="js">let array = [&quot;类型&quot;, &quot;影响&quot;, &quot;距离&quot;, &quot;推荐&quot;, &quot;预计&quot;]     array.map(function(item, index, arr)&#123;         // console.log(item+&#39;x&#39;, index, arr)        // 类型x 0 (5) [&quot;类型&quot;, &quot;影响&quot;, &quot;距离&quot;, &quot;推荐&quot;, &quot;预计&quot;]        // VM22:3 影响x 1 (5) [&quot;类型&quot;, &quot;影响&quot;, &quot;距离&quot;, &quot;推荐&quot;, &quot;预计&quot;]        // VM22:3 距离x 2 (5) [&quot;类型&quot;, &quot;影响&quot;, &quot;距离&quot;, &quot;推荐&quot;, &quot;预计&quot;]        // VM22:3 推荐x 3 (5) [&quot;类型&quot;, &quot;影响&quot;, &quot;距离&quot;, &quot;推荐&quot;, &quot;预计&quot;]        // VM22:3 预计x 4 (5) [&quot;类型&quot;, &quot;影响&quot;, &quot;距离&quot;, &quot;推荐&quot;, &quot;预计&quot;]         return item+&#39;x&#39;     &#125;)// (5) [&quot;类型x&quot;, &quot;影响x&quot;, &quot;距离x&quot;, &quot;推荐x&quot;, &quot;预计x&quot;]</code></pre><h5 id="4-Array-from"><a href="#4-Array-from" class="headerlink" title="4) Array.from()"></a>4) Array.from()</h5><h6 id="Array-from-将一个类数组对象或可遍历对象转化为一个真正的数组"><a href="#Array-from-将一个类数组对象或可遍历对象转化为一个真正的数组" class="headerlink" title="Array.from()将一个类数组对象或可遍历对象转化为一个真正的数组"></a>Array.from()将一个类数组对象或可遍历对象转化为一个真正的数组</h6><pre><code class="js">let arr1 = [12,45,97,9797,564,134,45642,12]let set = new Set(arr1)// [[Entries]]        // 0: 12        // 1: 45        // 2: 97        // 3: 9797        // 4: 564        // 5: 134        // 6: 45642        // size: 7,// 可以看到set不是一个数组，它看起来想一个对象，却又不是一个对象// console.log( Array.from(set))  // [12, 45, 97, 9797, 564, 134, 45642]</code></pre><h6 id="Array-from-还可将NodeList-转为真正的数组。"><a href="#Array-from-还可将NodeList-转为真正的数组。" class="headerlink" title="Array.from()还可将NodeList  转为真正的数组。"></a>Array.from()还可将NodeList  转为真正的数组。</h6><pre><code class="js">    var abc = document.getElementsByTagName(&#39;a&#39;)// 通过getElementsByTagName获取的元素不是一个数组，而是nodeList    console.log(typeof(abc),abc)  // 使用Array.from()    console.log(&#39;Array.form&#39;,Array.from(abc)) //[a, a, a, a, a, a, a, a]//第二种方法转化var arr = new Array()  // 这种方式新建数组很新颖    for(var i = 0; i &lt; abc.length; i++)&#123;        var ele = abc[i]        arr.push(ele)    &#125;    console.log(arr)  // [a, a, a, a, a, a, a, a]</code></pre><h5 id="5-合并对象-assign"><a href="#5-合并对象-assign" class="headerlink" title="5) 合并对象 assign"></a>5) 合并对象 assign</h5><pre><code class="js">let newObj = (&#123;&#125; ,config, &#123; key:Math.random()&#125;)</code></pre><h5 id="6）writing-mode"><a href="#6）writing-mode" class="headerlink" title="6）writing-mode"></a>6）writing-mode</h5><p>文字垂直显示</p><pre><code class="css">p&#123;writing-mode: vertical-lr&#125;</code></pre><h5 id="7）getAttribute-setAttribute"><a href="#7）getAttribute-setAttribute" class="headerlink" title="7）getAttribute\setAttribute"></a>7）getAttribute\setAttribute</h5><pre><code class="js">let pp = document.querySelector(&#39;input&#39;)pp.setAttribute(&#39;data-event&#39;, true)  // 添加属性let hasEvent = pp.getAttribute(&#39;data-event&#39;) // 获取对应键名对应的属性值console.log(hasEvent)  // true</code></pre><h5 id="8）Object-prototype-toString-call"><a href="#8）Object-prototype-toString-call" class="headerlink" title="8）Object.prototype.toString.call()"></a>8）Object.prototype.toString.call()</h5><h6 id="用Object-prototype-toString-call-obj-检测对象类型"><a href="#用Object-prototype-toString-call-obj-检测对象类型" class="headerlink" title="用Object.prototype.toString.call(obj)检测对象类型"></a>用Object.prototype.toString.call(obj)检测对象类型</h6><pre><code class="js">let arr = [&#39;Eric&#39;,&#39;Mary&#39;,&#39;Rose&#39;]    console.log(Object.prototype.toString.call(arr))  // [object Array]    console.log(Object.prototype.toString.call(&#39;Eric&#39;))  // [object String]    console.log(Object.prototype.toString.call(0))   // [object Number]    console.log(Object.prototype.toString.call(true))    // [object Boolean]    console.log(Object.prototype.toString.call(undefined))  // [object Undefined]    console.log(Object.prototype.toString.call(null))  // [object Null]    console.log(Object.prototype.toString.call(&#123;name:&quot;julius&quot;&#125;))  // [object Object]    console.log(Object.prototype.toString.call(function () &#123;&#125;))  // [object Function]    console.log(Object.prototype.toString.call([]))   // [object Array]    console.log(Object.prototype.toString.call(new Date))  // [object Date]    console.log(Object.prototype.toString.call(/^\[.*\]$/))  // [object RegExp]</code></pre><h6 id="判断数据类型-gt-函数调用"><a href="#判断数据类型-gt-函数调用" class="headerlink" title="判断数据类型====&gt;函数调用"></a>判断数据类型====&gt;函数调用</h6><pre><code class="js">function isNumber (number) &#123;        return  Object.prototype.toString.call(number) === &#39;[object Number]&#39;  // 字符串怎么能是true呢？    &#125;        console.log(isNumber(12))  // true</code></pre><h5 id="9）引入iconfont字体图标"><a href="#9）引入iconfont字体图标" class="headerlink" title="9）引入iconfont字体图标"></a>9）引入iconfont字体图标</h5><p>下载好并放入，import ‘./iconfont/iconfont.css’</p><pre><code class="html">// 使用：第一种方法 =&gt;  &lt;i *className*=&quot;iconfont icon-zanting&quot;&gt;&lt;/i&gt;</code></pre><pre><code class="html">// 第二种方法 =&gt; &lt;span class=&quot;icon iconfont&quot;&gt;&amp;#xe635;&lt;/span&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git操作</title>
      <link href="2021/04/30/git-cao-zuo/"/>
      <url>2021/04/30/git-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h4><pre><code>git add .</code></pre><pre><code>git commit -m </code></pre><pre><code>git push (若从远程上来下来，并切换了分支，那么可直接git push 就能将本地最新代码push到远程对应的这个分支上去)</code></pre><pre><code>git checkout 分支名 (已在远程对应的分支上，可使用此命令切换到其他远程分支)</code></pre><pre><code>git checkout -b 分支名 (创建本地分支)</code></pre><pre><code>git branch -a (查看所有分支，本地and远程)</code></pre><pre><code>git branch (查看本地分支)</code></pre><pre><code>git push --set-upstream origin 本地分支名(将本地分支推到远程仓库，使远程仓库下有该分支名)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组过滤undefined</title>
      <link href="2021/04/30/shu-zu-guo-lu-undefined/"/>
      <url>2021/04/30/shu-zu-guo-lu-undefined/</url>
      
        <content type="html"><![CDATA[<h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>我们在传递数据的时候，很多时候数据是一个数组，而又有些时候我们并不需要将整个数组传递过去，而是传递数组中的前几个对象；</p><p>这时就可以现在这样： method([list[0],list[1],list[2,list[3]])；</p><p>(调用父组件传递过来的函数，发送一个数组)；</p><p><strong>问题：数据都是调用后端接口得来的，而数据这个东西，有时候多，有时候少，多的时候就不说了，反正我们时以下标这样取得，怎么传也只有三条数据，但是数据少的时候问题就来了；</strong></p><p>什么问题呢？ 通过像这样传递的数据 method([list[0],list[1],list[2,list[3]])，<strong>如果数据一旦少于三条。也就是说如果调接口之得到一条数据</strong>，但是你这样通过下标传递数据, 那么发送过去的这个数组后两个必定是undefined!</p><p>将undefined发送给其他需要的组件，那么是极有可能出问题的，因此我们需要对数据进行处理：<strong>在数据为undefined时不发送数据！</strong></p><p>哪怕我只发送过去一条实际存在的数据，也不发送undefined,可以少传，可以不传，但不可以发undefined!</p><p>试了很多种方法，例如：</p><pre><code class="js">// list是我们要发送的数组// 将list 遍历&#123;    const [datas, setDatas] = useState([])...const res = await mydatas()const list = res.data...let newArr = []list.map( (item) =&gt; &#123;    if(item &amp;&amp; item!== undefined || item !== null || item !== &#39;&#39;)&#123;        newArr.push(item)    &#125;&#125;)    console.log(newArr) // [&#123;item&#125;,undefined,undefined] 结果依然没有发生变化,依然发送的是undefined    setDatas([list[0],list[1],list[2,list[3]])...&#125;</code></pre><p>解决：</p><pre><code class="js">setDatas([list[0],list[1],list[2,list[3]].filter( item =&gt; item)) console.log([list[0],list[1],list[2,list[3]].filter( item =&gt; item))  // 返回的新数组种没有undefined！！！// success</code></pre><p>原因：经过filter后会自动去掉undefined、null,空字符串。</p><pre><code class="js">var arr = [&#39;1&#39;,&#39;2&#39;,undefined, &#39;3.jpg&#39;,undefined, null、, &quot;&quot;]var newArr = arr.filter(item =&gt; item)console.log(newArr)VM23:3 (3) [&quot;1&quot;, &quot;2&quot;, &quot;3.jpg&quot;] // 可以看到undefined、null、&quot;&quot; 被去除了</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数组过滤undefined、null，&#39;&#39; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件冒泡的影响，两种hook</title>
      <link href="2021/04/28/shi-jian-mou-pao-de-ying-xiang-liang-chong-hook/"/>
      <url>2021/04/28/shi-jian-mou-pao-de-ying-xiang-liang-chong-hook/</url>
      
        <content type="html"><![CDATA[<h5 id="1-多个元素嵌套设有多个点击事件，最下级的元素触发点击事件可能发生冒泡情况。"><a href="#1-多个元素嵌套设有多个点击事件，最下级的元素触发点击事件可能发生冒泡情况。" class="headerlink" title="1. 多个元素嵌套设有多个点击事件，最下级的元素触发点击事件可能发生冒泡情况。"></a>1. 多个元素嵌套设有多个点击事件，最下级的元素触发点击事件可能发生冒泡情况。</h5><p><strong>冒泡</strong>：点击子元素的  点击事件， 会同时触发父组件的点击事件；</p><p><strong>在多个嵌套元素设置多个点击事件，极有可能发生此类问题！</strong></p><p>关于冒泡带来的问题，例如：    </p><pre><code class="jsx">// 在一个元素的父级 定义一个点击事件    // 在这个事件中定义一种状态或者是下标，function Cool()&#123;    ...    const [chooseIndex, setChooseIndex] = useState(undefined)    ...       changeIndex = (item, index) =&gt; &#123;  // 父级元素的点击事件        setChooseIndex(index)  // setChooseIndex改变初始值后  是必定会引发视图更新的！！    &#125;    closeStatus = (item, index) =&gt; &#123;        // 子节点的点击事件       setChooseIndex()    // 默认传空，chooseIndex 便不再等于index，但是visable 却没有关闭   &#125;                       // 在useEffect 和 reuturn打印发现值还是上一次的，也就是没有被改变    &#123;dataList.map( (item, index) =&gt; &#123;     // ****原因是因为，子元素每次closeStatus时都重新触发了changeIndex事件，因此closeStatus的值怎么都改不过来****    // **** 阻止事件冒泡即可    return &lt;Fragment&gt;        ...    ...         // 当chooseIndex == index 时，会出现两个效果，点击每一个变色；popver单个visable 属性true    &lt;div classname=&#123;cx(&#39;list-wrap&#39;, &#123;&quot;activeItemClass&quot; : chooseIndex === index&#125;)&#125;&gt;     &lt;Popver      content = &#123;renderContent()&#125;     visable=&#123;chooseIndex === index&#125;  // 当chooseIndex === index，即成立时，visable为true     &gt;                                // visable 在不成立，值不存在的情况下为false  例如： item.visable不存在为          false      &lt;div onClick=&#123;(e) =&gt; changeIndex(item, index)&#125;&gt;&lt;/div&gt;     &lt;/Popver&gt;    &lt;/div&gt;        &lt;/Fragment&gt;&#125;)&#125;       renderContent = (item, index) =&gt; &#123;        ...        ...        &lt;div         onClick = &#123;(e) =&gt; &#123;                e.stopPropagation()// 阻止事件冒泡                closeStatus()&#125;         &#125;&gt;&lt;div&gt;    &#125;&#125;</code></pre><p>2 . 补充：   useEffect 、useState</p><pre><code class="tex">useEffect 函数在  函数组件是可以多次定义的，这样的好处是：各放各的，不至于在有的状态和一个开关的值发生变化时，因为空数组传了值而重新调用useEffect 里面请求接口数据的函数，造成多次请求，严重影响页面性能。</code></pre><pre><code class="jsx">// 而定义的  const [content, setContnet] = useState(0) // 在set后是一定会重新刷新页面的，就像类的this.setSate(&#123;&#125;)也会重新调用render函数，重新刷新页面。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 事件冒泡、hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决OpenSSL报错</title>
      <link href="2021/04/27/jie-jue-openssl-bao-cuo/"/>
      <url>2021/04/27/jie-jue-openssl-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>首先，这个错误很可能是网络不稳定，连接超时导致的；</p><h5 id="若再次尝试依然报错，可输入如下命令"><a href="#若再次尝试依然报错，可输入如下命令" class="headerlink" title="若再次尝试依然报错，可输入如下命令"></a>若再次尝试依然报错，可输入如下命令</h5><pre><code class="js">git config --global http.sslVerify &quot;false&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git报错解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css磨砂效果，模糊效果</title>
      <link href="2021/04/27/css-mo-sha-xiao-guo-mo-hu-xiao-guo/"/>
      <url>2021/04/27/css-mo-sha-xiao-guo-mo-hu-xiao-guo/</url>
      
        <content type="html"><![CDATA[<p>要点：给需要磨砂的div(设rgba的那个元素) =&gt; 设置伪元素；</p><p>给伪元素content: ‘’、绝对定位，四处为0,left：0….</p><p>给伪元素一样的背景图，并给z-index: -1 、给自身z-index:1 ***重要，必须给！</p><p>最后给 伪元素 filter: blur(37px); 属性值，效果就出来了。</p><pre><code class="css">body&#123;background: url(./heroheart.jpg);   background-size: cover;&#125;#app&#123;margin: 100px auto;width: 600px;height: 370px;background: rgba(0,0,0,.5);padding: 100px;position: relative;z-index: 1;&#125;#app::after&#123;position: absolute;left: 0;top: 0;bottom: 0;right: 0;content: &#39;&#39;;background: url(./heroheart.jpg);background-size:cover ;z-index: -1;filter: blur(37px);&#125;p&#123;font-size: 28px;color: #FFFFFF;margin-bottom: 30px;&#125;</code></pre><pre><code class="html">&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;时间带走了回不去的青春，&lt;/p&gt;    &lt;p&gt;却带不走我一往无前的心！&lt;/p&gt;    &lt;p&gt;世间万物，万般困难、&lt;/p&gt;    &lt;p&gt;能耐我何？&lt;/p&gt;&lt;/div&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> css 磨砂，模糊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/25/hello-world/"/>
      <url>2021/04/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
